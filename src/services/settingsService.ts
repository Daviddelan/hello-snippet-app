import { supabase } from '../lib/supabase';
import { StorageService } from './storageService';

export interface OrganizerPreferences {
  logoUrl?: string;
  primaryColor: string;
  secondaryColor: string;
  themeAutoGenerated: boolean;
  eventPageTemplate: string;
  defaultCurrency: string;
  currencySymbol: string;
  notificationEmail: boolean;
  notificationSms: boolean;
  notificationNewRegistrations: boolean;
  notificationPaymentUpdates: boolean;
  notificationEventReminders: boolean;
  notificationMarketing: boolean;
  twoFactorEnabled: boolean;
}

export interface CurrencyInfo {
  code: string;
  name: string;
  symbol: string;
  rate?: number;
}

export const SUPPORTED_CURRENCIES: CurrencyInfo[] = [
  { code: 'USD', name: 'US Dollar', symbol: '$' },
  { code: 'EUR', name: 'Euro', symbol: '€' },
  { code: 'GBP', name: 'British Pound', symbol: '£' },
  { code: 'CAD', name: 'Canadian Dollar', symbol: 'CA$' },
  { code: 'AUD', name: 'Australian Dollar', symbol: 'A$' },
  { code: 'JPY', name: 'Japanese Yen', symbol: '¥' },
  { code: 'CNY', name: 'Chinese Yuan', symbol: '¥' },
  { code: 'INR', name: 'Indian Rupee', symbol: '₹' },
  { code: 'NGN', name: 'Nigerian Naira', symbol: '₦' },
  { code: 'ZAR', name: 'South African Rand', symbol: 'R' },
  { code: 'KES', name: 'Kenyan Shilling', symbol: 'KSh' },
  { code: 'GHS', name: 'Ghanaian Cedi', symbol: 'GH₵' },
];

export class SettingsService {
  static async getOrganizerPreferences(
    organizerId: string
  ): Promise<{
    success: boolean;
    preferences?: OrganizerPreferences;
    error?: string;
  }> {
    try {
      const { data, error } = await supabase
        .from('organizers')
        .select(
          `
          logo_url,
          primary_color,
          secondary_color,
          theme_auto_generated,
          event_page_template,
          default_currency,
          currency_symbol,
          notification_email,
          notification_sms,
          notification_new_registrations,
          notification_payment_updates,
          notification_event_reminders,
          notification_marketing,
          two_factor_enabled
        `
        )
        .eq('id', organizerId)
        .maybeSingle();

      if (error) {
        console.error('Error fetching preferences:', error);
        return { success: false, error: error.message };
      }

      if (!data) {
        return { success: false, error: 'Organizer not found' };
      }

      const preferences: OrganizerPreferences = {
        logoUrl: data.logo_url,
        primaryColor: data.primary_color || '#001B79',
        secondaryColor: data.secondary_color || '#0066CC',
        themeAutoGenerated: data.theme_auto_generated || false,
        eventPageTemplate: data.event_page_template || 'modern',
        defaultCurrency: data.default_currency || 'USD',
        currencySymbol: data.currency_symbol || '$',
        notificationEmail: data.notification_email !== false,
        notificationSms: data.notification_sms || false,
        notificationNewRegistrations: data.notification_new_registrations !== false,
        notificationPaymentUpdates: data.notification_payment_updates !== false,
        notificationEventReminders: data.notification_event_reminders !== false,
        notificationMarketing: data.notification_marketing || false,
        twoFactorEnabled: data.two_factor_enabled || false,
      };

      return { success: true, preferences };
    } catch (error) {
      console.error('Error in getOrganizerPreferences:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  static async updateOrganizerPreferences(
    organizerId: string,
    preferences: Partial<OrganizerPreferences>
  ): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      const updateData: any = {};

      if (preferences.logoUrl !== undefined)
        updateData.logo_url = preferences.logoUrl;
      if (preferences.primaryColor !== undefined)
        updateData.primary_color = preferences.primaryColor;
      if (preferences.secondaryColor !== undefined)
        updateData.secondary_color = preferences.secondaryColor;
      if (preferences.themeAutoGenerated !== undefined)
        updateData.theme_auto_generated = preferences.themeAutoGenerated;
      if (preferences.eventPageTemplate !== undefined)
        updateData.event_page_template = preferences.eventPageTemplate;
      if (preferences.defaultCurrency !== undefined)
        updateData.default_currency = preferences.defaultCurrency;
      if (preferences.currencySymbol !== undefined)
        updateData.currency_symbol = preferences.currencySymbol;
      if (preferences.notificationEmail !== undefined)
        updateData.notification_email = preferences.notificationEmail;
      if (preferences.notificationSms !== undefined)
        updateData.notification_sms = preferences.notificationSms;
      if (preferences.notificationNewRegistrations !== undefined)
        updateData.notification_new_registrations =
          preferences.notificationNewRegistrations;
      if (preferences.notificationPaymentUpdates !== undefined)
        updateData.notification_payment_updates =
          preferences.notificationPaymentUpdates;
      if (preferences.notificationEventReminders !== undefined)
        updateData.notification_event_reminders =
          preferences.notificationEventReminders;
      if (preferences.notificationMarketing !== undefined)
        updateData.notification_marketing = preferences.notificationMarketing;
      if (preferences.twoFactorEnabled !== undefined)
        updateData.two_factor_enabled = preferences.twoFactorEnabled;

      const { error } = await supabase
        .from('organizers')
        .update(updateData)
        .eq('id', organizerId);

      if (error) {
        console.error('Error updating preferences:', error);
        return { success: false, error: error.message };
      }

      return { success: true };
    } catch (error) {
      console.error('Error in updateOrganizerPreferences:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  static async uploadLogo(
    organizerId: string,
    file: File
  ): Promise<{
    success: boolean;
    url?: string;
    error?: string;
  }> {
    try {
      const result = await StorageService.uploadFile(
        file,
        `organizers/${organizerId}/logo`
      );

      if (!result.success || !result.url) {
        return { success: false, error: result.error || 'Upload failed' };
      }

      const updateResult = await this.updateOrganizerPreferences(organizerId, {
        logoUrl: result.url,
      });

      if (!updateResult.success) {
        return { success: false, error: updateResult.error };
      }

      return { success: true, url: result.url };
    } catch (error) {
      console.error('Error uploading logo:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  static extractColorsFromImage(file: File): Promise<{
    primaryColor: string;
    secondaryColor: string;
  }> {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            resolve({ primaryColor: '#001B79', secondaryColor: '#0066CC' });
            return;
          }

          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const pixels = imageData.data;
          const colorCounts: { [key: string]: number } = {};

          for (let i = 0; i < pixels.length; i += 4) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const a = pixels[i + 3];

            if (a < 125) continue;

            const brightness = (r + g + b) / 3;
            if (brightness > 240 || brightness < 15) continue;

            const quantizedR = Math.round(r / 32) * 32;
            const quantizedG = Math.round(g / 32) * 32;
            const quantizedB = Math.round(b / 32) * 32;

            const key = `${quantizedR},${quantizedG},${quantizedB}`;
            colorCounts[key] = (colorCounts[key] || 0) + 1;
          }

          const sortedColors = Object.entries(colorCounts)
            .sort((a, b) => b[1] - a[1])
            .map(([color]) => {
              const [r, g, b] = color.split(',').map(Number);
              return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            });

          const primaryColor = sortedColors[0] || '#001B79';
          const secondaryColor = sortedColors[1] || '#0066CC';

          resolve({ primaryColor, secondaryColor });
        };
        img.src = e.target?.result as string;
      };
      reader.readAsDataURL(file);
    });
  }

  static async getCurrencyExchangeRates(
    baseCurrency: string = 'USD'
  ): Promise<{
    success: boolean;
    rates?: { [key: string]: number };
    error?: string;
  }> {
    try {
      const response = await fetch(
        `https://api.exchangerate-api.com/v4/latest/${baseCurrency}`
      );

      if (!response.ok) {
        throw new Error('Failed to fetch exchange rates');
      }

      const data = await response.json();

      return {
        success: true,
        rates: data.rates,
      };
    } catch (error) {
      console.error('Error fetching exchange rates:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  static convertCurrency(
    amount: number,
    fromCurrency: string,
    toCurrency: string,
    rates: { [key: string]: number }
  ): number {
    if (fromCurrency === toCurrency) return amount;

    const amountInUSD = fromCurrency === 'USD' ? amount : amount / rates[fromCurrency];
    const convertedAmount = toCurrency === 'USD' ? amountInUSD : amountInUSD * rates[toCurrency];

    return Math.round(convertedAmount * 100) / 100;
  }

  static async changePassword(
    currentPassword: string,
    newPassword: string
  ): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      const { data: user } = await supabase.auth.getUser();

      if (!user.user?.email) {
        return { success: false, error: 'User not found' };
      }

      const { error: signInError } = await supabase.auth.signInWithPassword({
        email: user.user.email,
        password: currentPassword,
      });

      if (signInError) {
        return { success: false, error: 'Current password is incorrect' };
      }

      const { error: updateError } = await supabase.auth.updateUser({
        password: newPassword,
      });

      if (updateError) {
        return { success: false, error: updateError.message };
      }

      return { success: true };
    } catch (error) {
      console.error('Error changing password:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  static async updateProfile(
    organizerId: string,
    profileData: {
      firstName?: string;
      lastName?: string;
      phone?: string;
      location?: string;
      organizationName?: string;
      eventTypes?: string[];
    }
  ): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      const updateData: any = {};

      if (profileData.firstName !== undefined)
        updateData.first_name = profileData.firstName;
      if (profileData.lastName !== undefined)
        updateData.last_name = profileData.lastName;
      if (profileData.phone !== undefined) updateData.phone = profileData.phone;
      if (profileData.location !== undefined)
        updateData.location = profileData.location;
      if (profileData.organizationName !== undefined)
        updateData.organization_name = profileData.organizationName;
      if (profileData.eventTypes !== undefined)
        updateData.event_types = profileData.eventTypes;

      const { error } = await supabase
        .from('organizers')
        .update(updateData)
        .eq('id', organizerId);

      if (error) {
        console.error('Error updating profile:', error);
        return { success: false, error: error.message };
      }

      return { success: true };
    } catch (error) {
      console.error('Error in updateProfile:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  static async deleteAccount(organizerId: string): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      const { error: eventsError } = await supabase
        .from('events')
        .delete()
        .eq('organizer_id', organizerId);

      if (eventsError) {
        console.error('Error deleting events:', eventsError);
      }

      const { error: organizerError } = await supabase
        .from('organizers')
        .delete()
        .eq('id', organizerId);

      if (organizerError) {
        return { success: false, error: organizerError.message };
      }

      const { error: authError } = await supabase.auth.signOut();

      if (authError) {
        console.error('Error signing out:', authError);
      }

      return { success: true };
    } catch (error) {
      console.error('Error deleting account:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
}
